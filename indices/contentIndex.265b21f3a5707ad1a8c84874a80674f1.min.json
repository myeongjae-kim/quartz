{"/":{"title":"🪴 김명재","content":"\n\u003cp style=\"text-align:center\"\u003e\n\u003ca href=\"https://myeongjae.kim\"\u003emyeongjae.kim\u003c/a\u003e\n\u003c/p\u003e\n\n- [[notes/1-메모상자]]\n- [[notes/2-시-우리가-할-일은-웃는-것이다]]\n- [[notes/3-vscode-extensions]]\n- [[notes/3a-kill-port]]\n- [[notes/4-이력서]]\n- [[notes/5-기술]]\n- [[notes/5a-리액트-네이티브-디버깅-도구]]\n- [[notes/5b-bitrise에서-빌드한-앱을-슬랙-메시지-버튼으로-받기]]\n- [[notes/5c-url과-세미콜론]]\n- [[notes/5d-웹에서-한글-줄바꿈]]\n- [[notes/5e-프론트엔드-디렉토리-구성]]\n- [[notes/5f-모바일-웹브라우저에서-키패드-컨트롤]]\n- [[notes/5g-useQuery-wrapping하지-말기]]\n- [[notes/5h-프론트엔드-라이브러리]]\n- [[notes/5h1-ni-패키지-매니저-자동-선택]]\n- [[notes/5i-SSR시-캐시-주의]]\n- [[notes/5j-프론트엔드-스켈레톤은-200ms-이상일-때]]\n- [[notes/5k-why-functional-programming-matters]]\n- [[notes/5l-javascript-깊은복사-structured-clone]]\n- [[notes/5m-promise-관련-eslint-rules]]\n- [[notes/5m1-tsconfig-추천설정]]\n- [[notes/5n-react-native-naver-map-최신]]\n- [[notes/5o-스프링]]\n- [[notes/5o1-auto-commit-false]]\n- [[notes/5o2-rfc-7807]]\n- [[notes/5o3-spring-boot-release-notes]]\n- [[notes/5p-부하-테스트-도구]]\n- [[notes/5q-정규식으로-한글-돌릴-때-주의-유니코드]]\n- [[notes/5r-monorepo-tools]]\n- [[notes/5s-ux-pattern]]\n- [[notes/5t-aws]]\n- [[notes/5t1-aws-lambda-graalvm]]\n- [[notes/5t1-vpc-endpoint-gateway]]\n- [[notes/5u-kotlin]]\n- [[notes/5u1-kotlin-업데이트-따라잡기]]\n- [[notes/5v-cli-tools]]\n- [[notes/5v1-tlm-cli에서-작동하는-copilot]]\n- [[notes/5w-로컬-개발환경에서-https]]\n- [[notes/5x-자바스크립트-노트북]]\n- [[notes/6-학문의-자세]]\n- [[notes/7-ghost에-code-highlight]]\n- [[notes/8-서버-없이-브라우저에서-작동하는-pdftool]]\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/_index_head":{"title":"🪴 김명재","content":"\n\u003cp style=\"text-align:center\"\u003e\n\u003ca href=\"https://myeongjae.kim\"\u003emyeongjae.kim\u003c/a\u003e\n\u003c/p\u003e\n\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/1-%EB%A9%94%EB%AA%A8%EC%83%81%EC%9E%90":{"title":"1. 메모상자","content":"\n## 메모\n\n제텔카스텐은 상향으로 구성된다. 키워드가 먼저 있고 메모를 채우는게 아니라, *메모를 채우다보니 어떤 주제가 이미 상당히 발전해서 개요가 필요한 상태이거나 혹은 개요가 있으면 작은 도움이라도 얻을 수 있는 상태*가 되었기 때문에 인덱스에 추가하는 것이다. 영구 보관 메모들간의 연결에 가장 신경을 많이 써야 한다.\n\n메모를 연결하는 일이 제텔카스텐의 핵심이다. 키워드는 연결된 메모들에서부터 탄생한다. 제텔카스텐의 꽃이 '키워드'라면, '메모 연결'은 밭을 갈고 씨뿌리는 일이다.\n\n\u003e 우리는 링크를 만드는 일이 메모 상자를 유지 관리하는 차원의 허드렛일이 아님을 항상 명심해야 한다. 의미 있는 연결관계를 찾는 작업은 최종 원고를 완성하기 위해 생각하는 과정에서 결정적으로 중요한 역할을 한다. 이 단계는 상징적으로 우리의 내부의 기억을 찾는 대신, 문자 그대로 메모 상자를 살펴보고 연결성을 찾는 매우 구체적인 작업이다. 또한, 실제 메모를 다루기 때문에 무언가가 타당한지 아닌지를 문서로확인할 수 있어서 연결 관계가 없는 곳에서 연결 관계를 상상할 가능성도 적다.\n\n\n## 발췌\n\n\\- 숀케 아렌스, 제텔카스텐, 인간희극, 2021\n\n제텔카스텐의 디지털 버전들에서 메모들을 연결하는 것은 식은죽 먹기보다 더 간단하다. 그런데 아무리 어떤 프로그램이 공동 서지정보 등을 바탕으로 이렇게 저렇게 연결하려고 제안한다 해도, 제대로 교차 참조cross-references하는 작업은 만만치 않은 생각을 요하는 일이자 생각의 발전 과정에서 매우 중요한 부분이다.\n\n루만은 4가지 기본 유형의 교차 참조법을 활용했다[^20-p.173f;82-p.165f] 디지털 버전들에서는 이 가운데 첫 번째와 마지막 유형만 관련 있고, 나머지 두 가지는 종이와 펜을 사용하는 아날로그 버전의 제약을 상쇄하는 용도로만 필요하다. 따라서 디지털 프로그램을 사용한다면 이 두 가지는 신경 쓸 필요가 없다.\n\n1. 첫 번째 유형의 링크는 어떤 주제에 대한 개요를 제공하는 메모들과 연결된다. 이런 메모들은 색인에서 직접 연결된다. 어떤 주제가 이미 상당히 발전해서 개요가 필요한 상태이거나 혹은 개요가 있으면 작은 도움이라도 얻을 수 있는 상태라면, 특정 주제로 진입하는 엔트리 포인트로 대개 이런 메모가 사용된다. 이런 메모에는 특정 주제나 문제와 관련된 다른 메모들과의 링크를 모아둘 수 있는데, 이때 가급적이면 링크된 메모에 무슨 내용이 있는지 짧게 적어두면 좋다(한두 마디나 짧은 문장이면 족하다). 또한 이런 종류의 메모는 생각의 구조를 짜는 데 도움을 주기에, 원고를 발전시키기 전의 중간 단계로 간주하면 된다. 무엇보다도 이런 메모는 메모 상자 안에서 방향을 잃지 않게 도와준다. 여러분도 이런 메모를 써야 할 때가 되면 다 실감하게 될 것이다. 루만은 이런 종류의 엔트리 포인트 메모에 다른 메모와의 링크를 최대 25개까지 기록하기도 했다. 물론 링크는 시간이 지나면서 추가될 수 있으므로, 한꺼번에 이렇게 많이 기록할 필요는 없다. 우리는 이렇게 링크가 추가되는 것만 봐도 그 주제가 얼마나 유기적으로 늘어날 수 있는지 알 수 있다. 어떤 주제와 관련이 있느냐, 없느냐 하는 판단은 우리가 현재 이해하고 있는 바에 따라 달라지며, 매우 진지한 판단이 이루어져야 한다. 아이디어는 그 바탕이 되는 사실이 얼마나 많은가에 따라 그만큼 명확히 규정되기 때문이다. 우리가 어떤 주제와 관련 있다고 보는 관점과 이것을 구조화하는 방법은 시간이 흐르면서 달라진다. 이런 변화는 더욱 적합한 또 다른 주제 구조를 지닌 새로운 메모로 이어질 수 있으며, 그 메모는 이전의 메모에 대한 코멘트로 간주될 수 있다. 감사하게도 이런 순간에도 나머지 모든 메모가 쓸모없게 되지는 않는다. 앞서 언급한 바와 같이, 색인의 엔트리 항목을 이 새 메모로 바꾸거나 추가적으로 옛 메모에 '이제는 새 구조가 더 적합한 것으로 보인다'는 언급만 하면 된다.\n2. 위와 유사하지만 덜 중요한 링크들은 메모 상자의 지엽적, 물리적 무리cluster에 대한 개요를 제공하는 메모들과 관련된다. 이것은 루만처럼 종이와 펜으로 아날로그식 작업을 하는 경우에만 필요하다. 첫 번째 유형의 메모는 메모 상자 속 메모의 위치와 무관하게 어떤 주제에 대한 개요를 제공하는 반면, 이 두 번째 유형의 메모는 물리적으로 가까운 곳에 있는 메모에서 논의되는 모든 주제를 파악하는 실용적인 방법이 된다. 메모들 사이에 메모를 집어넣어 내부적으로 부주제와 부부주제가 가지를 뻗도록 만들면 원래의 사고방식이 다양한 메모들 때문에 방해받는 경우가 종종 있는데 이 두 번째 유형의 메모가 원래의 사고방식을 놓치지 않고 파악하게 해주는 것이다. 물론, 디지털 버전 프로그램으로 작업하는 경우에는 이 문제를 염려할 필요가 없다.\n3. 세 번째 링크들도 마찬가지로 디지털 버전에서는 관련성이 적다. 이 링크들은 현재 메모의 선행 메모를 가리키기도 하고 현재 메모의 후속 메모를 가리키기도 한다. 이 링크들은 물리적으로 가까이 붙어있지 않은 메모들이라도 어떤 메모들끼리 서로 이어지는지 알게 되는 데 의의가 있다.\n4. 가장 일반적인 형태의 참조방식은 단순한 메모 대 메모 링크다. 이 경우에는 두 개의 개별 메모 사이의 적절한 연결 관계를 보여주는 것 이외의 기능은 없다. 관련된 두 메모가 메모 상자 안 어디에 있건, 혹은 다른 맥락 속 어디에 있건 상관없이 이 두 메모를 연결함으로써 놀랍고도 새로운 사고방식이 구축될 수 있다. 이 같은 메모 대 메모 링크는 우리가 안면 있는 사람들과 맺고 있는 사회적 관계상의 \"약한 유대관계\"[^112] 와 비슷하다. 대개 우리가 가장 먼저 찾는 대상은 아니지만, 그래도 우리에게 새롭고 다양한 관점을 제공해주는 경우가 많다는 점에서 그렇다.\n\n이러한 링크 덕분에 우리는 외견상 관계없이 보이는 주제들 사이에서도 놀라운 연결성과 유사성을 발견할 수 있다. 패턴이 당장 눈에 띄지는 않겠지만, 두 주제 사이의 메모 대 메모 링크가 다수 구축되고 나면 그 모습을 서서히 드러내기 시작할 것이다. 루만의 사회 시스템 이론의 주요 특징 중 하나가 매우 다양한 사회분야에서 찾을 수 있는 구조적 패턴의 발견이라는 사실은 그저 우연이 아니다. 예를 들어 루만은 돈, 권력, 사랑, 진리, 정의 같은 다양한 가치들이 어떻게 구조적으로 유사한 문제들을 해결하는 사회적 발명품으로 여겨질 수 있는지를 입증할 수 있었다(이것들은 모두 커뮤니케이션 제의를 수용할 가능성을 높이는 매체로 여겨질 수 있다. 니클라스 루만의 『사회의 사회』 9~12장 참고).[^18] 반면, 미리 생각해 둔 테마와 주제에 따라 모든 것이 깔끔하게 분리된 시스템으로 작업하는 사람은 이 같은 의견을 결코 제시할 수도, 설명할 수도 없다.\n\n한편, 우리는 링크를 만드는 일이 메모 상자를 유지 관리하는 차원의 허드렛일이 아님을 항상 명심해야 한다. 의미 있는 연결관계를 찾는 작업은 최종 원고를 완성하기 위해 생각하는 과정에서 결정적으로 중요한 역할을 한다. 이 단계는 상징적으로 우리의 내부의 기억을 찾는 대신, 문자 그대로 메모 상자를 살펴보고 연결성을 찾는 매우 구체적인 작업이다. 또한, 실제 메모를 다루기 때문에 무언가가 타당한지 아닌지를 문서로확인할 수 있어서 연결 관계가 없는 곳에서 연결 관계를 상상할 가능성도 적다.\n\n이런 연결을 만들어 내는 주체는 다름 아닌 우리 자신이기 때문에, 우리는 메모 상자의 내부 구조를 생각으로 구축할 수 있다. 제한된 기억과는 독립적으로 외부에도 이런 구조를 구축하는 만큼, 우리는 더욱 구조적인 방식으로 생각할 수 있게 될 것이며, 여러 사실들과 심사숙고한 아이디어, 검증 가능한 참고자료로 이루어진 네트워크 안에 우리 아이디어의 뿌리를 내리게 될 것이다. 또한 메모 상자는 많은 정보를 가지고 있는 현실적인 커뮤니케이션 파트너와 같아서 우리가 현실감을 잃지 않게 해준다. 혹시라도 우리가 다소 뜬구름 잡는 아이디어를 추가하려 들면, 메모 상자는 우리가 다음과 같은 사항을 먼저 점검하게끔 만든다. 참고자료가 무엇인가? 기존에 가지고 있는 아이디어나 사실과는 어떻게 연결되는가?","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/2-%EC%8B%9C-%EC%9A%B0%EB%A6%AC%EA%B0%80-%ED%95%A0-%EC%9D%BC%EC%9D%80-%EC%9B%83%EB%8A%94-%EA%B2%83%EC%9D%B4%EB%8B%A4":{"title":"2. (시) 우리가 할 일은 웃는 것이다","content":"\n**[우리가 할 일은 웃는 것이다(이승훈)](https://www.personar.kr/music/우리가-할-일은-웃는-것이다이승훈-i**-홍일표/)**\n\n\u003e 웅성거리는 삶 헤매고 떠도는 삶 술에 취해 주정도 하고 실수도 하는 삶이 세계입니다 고상한 영혼 따윈 없죠 형이상학도 없습니다 모두가 언어죠 후회도 언어 기쁨도 언어 모래도 언어 지금 저리는 팔도 언어 어제 들른 카페도 언어 당신도 언어입니다 언어의 한계가 세계의 한계이고 당신의 한계죠 당신의 한계가 세계의 한계입니다 당신은 당신의 눈을 볼 수 없고 당신은 지금 추운 들판, 거리, 마른 나무를 보는 게 아니라 당신의 시야 속에 있습니다 당신의 시야가 세계이고 세계의 한계죠 결국 사유는 미친 짓이죠 무슨 영혼, 진리, 본질 따윈 버리세요 잊으세요 망각하세요 세계와 거리를 두지 마세요 그저 사세요 영혼 따위에 속지 마세요 진리를 찾지 마세요 삶이 그대로 진리입니다 당신의 진리가 있는 게 아니라 당신이 진리죠 오전엔 눈이 오고 오후엔 해가 납니다\n\n유물론 좋아. 현실을 살게 하는 건조한 말이 좋다.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/3-vscode-extensions":{"title":"3. VSCode extensions","content":"\n## Pretty TypeScript Errors\n\n읽기 힘든 타입스크립트 타입 에러를 읽기쉽게 바꿔주는 vscode 플러그인\n\nhttps://marketplace.visualstudio.com/items?itemName=yoavbls.pretty-ts-errors\n![[notes/images/image (18).png]]","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/3a-kill-port":{"title":"3a. kill-port","content":"\nhttps://twitter.com/dannypostmaa/status/1647790681568706561?s=46\u0026t=WWPMzoEtNZZ_eqp7T45DPQ\n\n![[notes/images/Ft4g4anaAAAu0U5.jpeg]]","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/4-%EC%9D%B4%EB%A0%A5%EC%84%9C":{"title":"4. 이력서","content":"\n안녕하세요, 김명재입니다.\n\n\u003ctable style=\"border: 0; margin-bottom: 4rem;\"\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"border: 0;\"\u003e\n        \u003cul\u003eEmail: \u003ca href=\"mailto:dev@myeongjae.kim\"\u003edev@myeongjae.kim\u003c/a\u003e\u003c/ul\u003e\n        \u003cul\u003ePhone: 010-0000-0000\u003c/ul\u003e\n        \u003cul\u003eBlog: \u003ca href=\"https://myeongjae.kim\"\u003ehttps://myeongjae.kim\u003c/a\u003e\u003c/ul\u003e\n      \u003c/td\u003e\n      \u003ctd style=\"border: 0;\"\u003e\n        \u003cimg src=\"https://cdn.myeongjae.kim/res/profile.jpg\" width=\"256\"\u003e\n      \u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n## 저는\n\n- 담당하는 시스템이 최소한의 복잡도를 갖도록 일합니다: [https://myeongjae.kim/blog/2020/02/05/single-principle-of-a-developer](https://myeongjae.kim/blog/2020/02/05/single-principle-of-a-developer)\n\t- 엔지니어링의 고통은 복잡함에서 발생하기 때문입니다.\n\t- 고통의 총량을 줄이는 것이 평생의 목표입니다.\n\n## 이력\n\n### 디어코퍼레이션\n\n#### 기간\n\n2022.05.02 ~ 현재\n\n#### 업무\n- 모빌리티서비스팀 풀스택 개발자 (2023.05.01 ~ 현재)\n- 물류팀 테크리드 (2022.06.01 ~ 2023.04.30)\n\t- 화물 주선사 대상 SaaS 개발 (배차 \u0026 정산)\n- 모빌리티서비스팀 프론트엔드 리드 (2022.05.02 ~ 2022.05.31)\n- Spring Boot, Terraform, Next.js, React Native, TypeScript\n\n#### 기여한 기술력\n\n##### 모빌리티서비스팀 풀스택 개발자 (2023.05.01 ~ 현재)\n\n- 디어 앱 CI/CD 파이프라인 구축\n- 디어 앱 개발 과정에 TDD(Test Driven Development) 도입\n- 동종업계 S사 API의 종단간 암호화 알고리즘과 암호키 추출\n- 전사 VPN 셋업 및 구글 로그인 연동\n- 쿼리를 공유할 수 있는 도구인 [Apache Zeppelin](https://zeppelin.apache.org/)을 도입해서 디어 데이터 분석 인프라를 마련함\n- Next.js v13의 [App Router](https://nextjs.org/docs/app)로 웹 애플리케이션을 작성하면서 필요한 라이브러리를 직접 구현\n\t- [return-fetch :: A simple and powerful high order function to extend fetch](https://return-fetch.myeongjae.kim/)\n\t- [Next.js v13 \u0008App Router로 제품 만들기: 이제 더 이상 Axios를 쓰지 않기로 했습니다](https://myeongjae.kim/blog/2023/08/04/next-js-app-router-and-fetch-library)\n- React Native로 디어 앱, Next.js로 웹뷰 기능 구현\n\n##### 물류팀 테크리드 (2022.06.01 ~ 2023.04.30)\n\n화물 주선사 대상 SaaS 개발 (배차 \u0026 정산)\n\n- AWS 인프라를 VPC부터 Terraform으로 설계 및 구축\n- AWS ECS, AWS Fargate를 사용하는 배포환경 구축\n- Kotlin Spring으로 백엔드 API 구현\n- 백엔드 API의 모든 기능에 대한 테스트 작성\n- 배치 성격의 프로그램을 [serverless framework](https://www.serverless.com/)로 작성\n\t- serverless, AWS Lambda, EventBridge\n- 화물 플랫폼들의 API를 분석하고 종단간 암호화 알고리즘과 암호키 추출\n- OLAP(Online Analytical Process) 워크로드를 감당할 수 있는 시스템 도입\n\t- AWS Athena, Apache Zeppelin\n- pnpm workspace를 활용해서 전사 프론트엔드 모노레포 도입 (10개 이상의 웹앱을 모노레포에서 관리)\n- Jira의 Release기능을 활용한 버전관리 프로세스 제안 및 도입\n\t- Jira Automation을 활용해서 릴리즈노트 자동 생성, 슬랙 알림 전송, GitHub에 Release draft 자동생성함\n\n##### 모빌리티서비스팀 프론트엔드 리드 (2022.05.02 ~ 2022.05.31)\n\n- 리액트 네이티브 모노레포 템플릿 작성 (yarn workspace를 활용해서)\n- Bitrise를 도입해서 앱 CI/CD를 구성\n- Trunk Based Development 문화\n\n\n---\n\n### 우아한형제들\n\n#### 기간\n\n2018.10.15 ~ 2022.04.30\n\n#### 업무\n\n- 만화경 백엔드/프론트엔드/추천시스템 개발\n\t- 만화경 팀의 두 번째 개발자로 입사\n- Spring Boot, Spring Data JPA, Spring Web MVC, Spring WebFlux, Spring Data R2DBC, Spring OAuth2, TypeScript, React, Next.js, Redux, Redux Saga, lerna\n\n#### 기여한 기술력\n\n- 백엔드 애플리케이션 아키텍처 설계 및 구현 (적극적인 TDD 활용)\n\t- 도메인 영역에 세부사항이 침투하지 않도록 [Gradle 멀티모듈](https://techblog.woowahan.com/2637/) 구조 적용\n\t- 도메인 모듈을 API와 배치 애플리케이션에서 공용으로 쓸 수 있도록 개선\n- 백오피스 CMS 프론트엔드 설계 및 구현 (Next.js, Redux, Redux Saga)\n\t- 내부용, 작가용 어드민을 하나의 저장소에서 관리하기 위해 lerna로 모노레포 구조 적용\n- 추천시스템 구현 (AWS Personalize, AWS StepFunctions, Apache Airflow)\n- gif resize가 가능한 image-api 설계 및 구현 (sharp)\n- 백엔드 API의 언어를 자바에서 코틀린으로 전환하는 프로젝트를 제안하고 수행\n\t- 코틀린 스터디그룹을 운영해서 구성원들과 함께 기술을 학습함. 책 [Atomic Kotlin](https://www.atomickotlin.com) 학습\n\t- 테스트 코드부터 먼저 코틀린으로 변환하고, 변환하는 과정에서 kotest, mockk등을 적용함\n\t- 테스트 코드의 변환이 완료된 이후부터 새로 작성하는 main코드들도 코틀린으로 작성함\n\t- 자바로 작성한 부분에 요구사항이 발생하면 코틀린으로 변환 후 요구사항을 반영함\n- 개인별 추천 데이터에 기반한 푸시알림 자동화 (Apache Airflow, Braze)\n\n#### 성과\n\n- **3년만에 T1에서 T3직급까지 두 번 승진**\n- 만화경 웹툰 플랫폼의 비즈니스 요구사항을 만족하는 백엔드 API와 백오피스 CMS 프론트엔드 구현\n\n---\n\n### 개인 홈페이지 운영\n\nhttps://myeongjae.kim\n\n#### 기간\n\n2018.08.13 ~ 현재\n\n#### 목적\n\n학습용 프로젝트. 기술적으로 관심이 가는 기술을 현업에 적용해보기 전에 실험해보는 테스트베드가 주요 용도이며, 평소에 드는 생각이나 회사 기술블로그에 기고한 글을 아카이빙하는 목적으로도 운영중.\n\n#### 학습했던 기술\n\nAWS VPC, AWS EC2, AWS ECS, Vuejs, Go, React, Next.js, TypeORM, InversifyJS, Spring Boot, Docker, Strapi, Heroku\n\n---\n\n### The University of Austin at Texas (미국 텍사스)\n\n#### 기간\n2018.04 ~ 2018.05\n\n#### 업무\n\n- curl library를 활용한 데이터 전송 프로그램 구현\n- C++, libcurl, sftp, expect (linux cli), crontab\n\n#### 기여한 기술력\n\n[UT Austin 간호대학](https://nursing.utexas.edu)에서 사용하던 프로그램이 유지보수가 되고있지 않던 상황에서, 기존의 소스코드를 받아 프로그램이 제대로 작동하도록 구현을 마무리 했다.\n\n프로그램은 A서버에서 환자의 기록을 받아와 B,C 서버로 보낸다. A서버에서 받은 문자열 데이터를 B,C서버가 요구하는 포맷에 맞게 처리하고 전송한다.\n\n프로젝트를 넘겨받았을 때는 전임자가 프로그램을 설계하고 curl library를 활용하는 클래스까지만 구현한 상태였다. 설계 문서를 보고 A서버에 request를 보내서 데이터를 받아오는 부분, 받아온 문자열 데이터를 처리하는 부분, 받은 데이터를 B,C서버로 전송하는 부분을 구현했다.\n\nC++로 작성한 프로그램에서는 A서버의 데이터를 받아와 B,C 서버가 요구하는 포맷의 csv데이터를 생성한다. 데이터 생성이 완료되면 expect용 스크립트를 생성하고 실행한다. expect 스크립트에서는 sftp로 csv파일을 B,C 서버에 전송한다.\n#### 성과\n\n- 목표했던 프로그램을 완성.\n- libcurl 라이브러리의 활용법 학습.\n- expect를 통해 CLI 상호작용을 자동화하는 방법 학습.\n- crontab을 활용해서 프로세스를 정해진 시간에 자동으로 실행하는 방법 학습.\n\n---\n\n### Sandman Media Inc. (캐나다 벤쿠버)\n\nhttps://www.sandmanmedia.com\n\n#### 기간\n2017.01 ~ 2017.02\n\n#### 업무\n- Joomla(CMS) 기반 웹페이지 개발\n- HTML, CSS, PHP\n\n#### 성과\n\nCEO에게 추천서를 받고 Fast learner라고 인정을 받음.\n\n[https://cdn.myeongjae.kim/blog/2023/05/김명재_추천서_Sandeep_Reference_Letter.pdf](https://cdn.myeongjae.kim/blog/2023/05/김명재_추천서_Sandeep_Reference_Letter.pdf)\n\n\u003cembed src=\"https://cdn.myeongjae.kim/blog/2023/05/김명재_추천서_Sandeep_Reference_Letter.pdf\" style=\"width: 100%; height: 80vh;\"\u003e\n\n---\n\n## 기고\n- [(2023.08.09) Next.js App Router로 제품 만들기: 이제 더 이상 Axios를 쓰지 않기로 했습니다 - 디어코퍼레이션 기술블로그](https://blog.deering.co/next-js-app-router-and-fetch-library/)\n- [(2023.04.17) 모든 IT 스타트업에서 꼭 작성해야 하는 프론트엔드 단위 테스트가 있다? (로깅, 단위 테스트, 그리고 의존성 주입) - 디어코퍼레이션 기술블로그](https://blog.deering.co/frontend-unit-test-you-must-write/) \n- [(2022.11.15) 스타트업 개발 생산성 높이기: (2) 숨어있는 비용을 찾아 없애자 - 디어코퍼레이션 기술블로그](https://blog.deering.co/cost-reducing/)\n- [(2022.11.15) 스타트업 개발 생산성 높이기 (1): Shape Up - 디어코퍼레이션 기술블로그](https://blog.deering.co/shape-up/)\n- [(2022.05.18) 개발자의 일이관지一以貫之 - 디어코퍼레이션 기술블로그](https://blog.deering.co/abstract-engineering/)\n- [(2022.04.30) git branch 이름과 hook으로 commit message 컨벤션 강제하기 - 디어코퍼레이션 기술블로그](https://blog.deering.co/commit-convention/)\n- [(2022.04.05) '우아한형제들 구성원들의 책 추천!' 영상 제작에 참여 - 우아한형제들 유튜브](https://youtu.be/J1lkYT0g2bM?t=74)\n- [(2020.11.04) AWS DNA 1기 수상 및 인터뷰 진행](http://blog.creation.net/channy-cloud-clinic-ep23)\n- [(2019.06.12) Spring Boot에서 Repository로 DynamoDB 조작하기 (2) – Gradle을 활용해 실행 \u0026 테스팅 환경 구축 - 우아한형제들 기술블로그](https://techblog.woowahan.com/2634/)\n- [(2019.06.05) Spring Boot에서 Repository로 DynamoDB 조작하기 (1) – 설정부터 실행까지 - 우아한형제들 기술블로그](https://techblog.woowahan.com/2633/)\n\n## 자격증\n\n- (2021.06.02) 정보처리기사\n- [(2020.09.14) AWS Certified Solutions Architect – Associate](https://www.credly.com/badges/732992e0-7ae1-4b46-b3b1-35949f8030ac)\n\n## 학력\n\n- 한양대학교 컴퓨터전공 (2012.02 ~ 2020.08)","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5-%EA%B8%B0%EC%88%A0":{"title":"5. 기술","content":"\n5번 항목에서는 기술과 관련된 내용을 다룹니다.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5a-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%94%94%EB%B2%84%EA%B9%85-%EB%8F%84%EA%B5%AC":{"title":"5a. 리액트 네이티브 디버깅 도구","content":"\n1. [react-native-debugger](https://github.com/jhen0409/react-native-debugger)\n2. [Flipper](https://fbflipper.com)\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5b-bitrise%EC%97%90%EC%84%9C-%EB%B9%8C%EB%93%9C%ED%95%9C-%EC%95%B1%EC%9D%84-%EC%8A%AC%EB%9E%99-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B2%84%ED%8A%BC%EC%9C%BC%EB%A1%9C-%EB%B0%9B%EA%B8%B0":{"title":"5b. Bitrise에서 빌드한 앱을 슬랙 메시지 버튼으로 받기","content":"\n별거 아니지만 설정하는데 깨나 시간을 써서 아까워서 기록해놓는다.\n\n```yml\n    - script@1:\n        inputs:\n        - content: |-\n            #!/usr/bin/env bash\n\n            LIST=(${BITRISE_PUBLIC_INSTALL_PAGE_URL_MAP//|/ })\n            INSTALL_PAGE_0=${LIST[0]//=\u003e/|}\n            INSTALL_PAGE_1=${LIST[1]//=\u003e/|}\n            INSTALL_PAGE_2=${LIST[2]//=\u003e/|}\n            INSTALL_PAGE_3=${LIST[3]//=\u003e/|}\n\n            envman add --key INSTALL_PAGE_BUTTON_0 --value \"$INSTALL_PAGE_0\"\n            envman add --key INSTALL_PAGE_BUTTON_1 --value \"$INSTALL_PAGE_1\"\n            envman add --key INSTALL_PAGE_BUTTON_2 --value \"$INSTALL_PAGE_2\"\n            envman add --key INSTALL_PAGE_BUTTON_3 --value \"$INSTALL_PAGE_3\"\n    - slack@3:\n        inputs:\n        - channel: \"$SLACK_CHANNEL\"\n        - pretext: \"*(staging)App Build Succeeded!* Build Number: $BITRISE_BUILD_NUMBER\"\n        - buttons: |-\n            ${INSTALL_PAGE_BUTTON_0}\n            ${INSTALL_PAGE_BUTTON_1}\n            ${INSTALL_PAGE_BUTTON_2}\n            ${INSTALL_PAGE_BUTTON_3}\n            View Build|${BITRISE_BUILD_URL}\n            View App|${BITRISE_APP_URL}\n        - webhook_url_on_error: \"$SLACK_API_TOKEN\"\n        - api_token: \"$SLACK_API_TOKEN\"\n        is_always_run: false\n    - slack@3:\n        inputs:\n        - channel: \"$SLACK_CHANNEL\"\n        - pretext: \"*(staging)App Build Failed!* Build Number: $BITRISE_BUILD_NUMBER\"\n        - color: \"#a63636\"\n        - api_token: \"$SLACK_API_TOKEN\"\n        is_always_run: true\n        run_if: \".IsBuildFailed\"\n```","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5c-url%EA%B3%BC-%EC%84%B8%EB%AF%B8%EC%BD%9C%EB%A1%A0":{"title":"5c. URL과 세미콜론","content":"\n세미콜론(;)은 URL에서 사용할 수 있는 문자다. 하지만 path parameter를 구분하는데 사용하고, query parameter에서는 일반 문자로 취급해야 한다.\n\n\u003e In other words, `?foo=bar;baz` means the parameter `foo` will have the value `bar;baz`; whereas `?foo=bar;baz=sna` should result in `foo` being `bar;baz=sna` (although technically illegal since the second `=` should be escaped to `%3D`).\n\u003e\n\u003e - https://stackoverflow.com/a/40768572\n\n예전에 쿼리 파라미터를 구분할 때 쓰는 암퍼센드(\u0026)를 세미콜론(;)으로 대체하려는 시도가 있었지만, 지금은 obsolete되었고 쿼리 파라미터를 구분할 때는 암퍼센드(\u0026)만 사용해야 한다.\n\n하지만 path parameter를 구분하는데 사용하는 세미콜론(;)은 여전히 유효하다. 예를 들어서 `http://www.blah.com/some/crazy/path.html;param1=foo;param2=bar`\n\n### 참고\n- https://stackoverflow.com/a/40768572\n- https://stackoverflow.com/a/18830337","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5d-%EC%9B%B9%EC%97%90%EC%84%9C-%ED%95%9C%EA%B8%80-%EC%A4%84%EB%B0%94%EA%BF%88":{"title":"5d. 웹에서 한글 줄바꿈","content":"\nhttps://www.w3.org/TR/css-text-3/#word-break-property\n\n```css\nword-break: keep-all;\ntext-align: left;\n```\n\n단어 끊어지게 줄바꾸지 말고, 양쪽정렬 하지 말고 좌측정렬로 하자\n\n- [미움 받는 왼끝맞춤에 대한 변호](https://fdsctxt.oopy.io/74cfe0a0-d836-44a6-973a-cf7f722ac880) ([아카이브](https://web.archive.org/web/20220109131143/https://fdsctxt.oopy.io/74cfe0a0-d836-44a6-973a-cf7f722ac880))","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5e-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC-%EA%B5%AC%EC%84%B1":{"title":"5e. 프론트엔드 디렉토리 구성","content":"  \n도메인 주도 설계의 철학을 따른다. 아토믹 디자인의 컴포넌트 구분을 따른다.\n\n- 특정 기능의 하위 디렉토리는 아래와 같이 구성한다.\n  - adapters: 시스템 외부와 통신하는 객체를 정의한다. 외부 의존성을 담당한다. Container 컴포넌트가 adapters의 객체를\npresentational component나 business logic에 주입해서 연결하는 역할을 한다.\n  - components/molecules: html 기본 태그로 이루어진 간단한 컴포넌트\n  - components/organisms: html 기본 태그와 molecule 컴포넌트로 이루어진 복잡한 컴포넌트\n  - components/templates: 페이지 레이아웃을 구성하는 컴포넌트. 상태는 외부에서 주입받는다.\n  - containers: 외부 의존성을 담당한다. 상태를 관리하고 상태를 presentational components나 비즈니스 로직에 주입한다. UI는 최대한 배제한다.\n  - domain/application: 비즈니스 로직을 담당한다. 외부 의존성을 주입받아서 사용한다. 비즈니스 로직 특성에 따라 순수한 타입스크립트 코드나 \nreact hook으로 작성한다. utility 성격(=core)의 의존성은 직접 의존할 수 있다.\n  - domain/model: 기능의 핵심이 되는 모델을 선언한다.\n\n```\nsrc\n└── feature\n    ├── adapters\n    │   └── apiClient.ts\n    ├── components\n    │   ├── molecules\n    │   │   └── PresentationalComponent.tsx\n    │   ├── organisms\n    │   │   └── PresentationalComponentComposed.tsx\n    │   └── templates\n    │       └── TemplatesStatesShouldBeInjected.tsx\n    ├── containers\n    │   └── SomeContainer.tsx\n    └── domain\n        ├── application\n        │   ├── businessLogic.ts\n        │   └── useBusinessLogicHook.ts\n        └── model\n            └── DomainModel.ts\n```\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5f-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%9B%B9%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%ED%82%A4%ED%8C%A8%EB%93%9C-%EC%BB%A8%ED%8A%B8%EB%A1%A4":{"title":"5f-모바일-웹브라우저에서-키패드-컨트롤","content":"```ts\n/**  \n * https://stackoverflow.com/a/55652503\n * iOS/Android 웹브라우저에서 input에 focus를 줄 때 keyboard가 올라오도록 도와주는 함수.  \n * 매개변수의 focus 함수에서 focusing을 하지 않으면, 함수 호출 직전에 focusing 되어있던 input은 blur가 되고 keyboard가 내려간다.  \n * @param focus 특정 input에 focus를 줄 때 사용하는 함수  \n * @param timeoutMs 실행 순서를 보장하기 위한 setTimeout함수에 넣을 값. 0으로 사용해도 무방하다.  \n */\nexport const focusAfterBlur = (focus: () =\u003e void, timeoutMs = 0) =\u003e {  \n  // create invisible dummy input to receive the focus first  \n  const fakeInput = document.createElement('input');  \n  fakeInput.setAttribute('type', 'text');  \n  fakeInput.style.position = 'absolute';  \n  fakeInput.style.opacity = '0';  \n  fakeInput.style.height = '0';  \n  fakeInput.style.fontSize = '16px'; // disable auto zoom  \n  \n  // you may need to append to another element depending on the browser's auto  // zoom/scroll behavior  document.body.prepend(fakeInput);  \n  \n  // focus so that subsequent async focus will work  \n  fakeInput.focus();  \n  \n  setTimeout(() =\u003e {  \n    // now we can focus on the target input  \n    focus();  \n  \n    // cleanup  \n    fakeInput.remove();  \n  }, timeoutMs);  \n};\n```","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5g-useQuery-wrapping%ED%95%98%EC%A7%80-%EB%A7%90%EA%B8%B0":{"title":"5g. useQuery wrapping하지 말기","content":"\nreact-query contributor가 useQuery함수의 옵션을 다 받을 수 있는 커스텀훅 만들지 말고 그냥 useQuery를 쓰라고 한다: [https://twitter.com/tkdodo/status/1680944472694169603?s=46\u0026t=WWPMzoEtNZZ_eqp7T45DPQ](https://twitter.com/tkdodo/status/1680944472694169603?s=46\u0026t=WWPMzoEtNZZ_eqp7T45DPQ)\n\n\u003e creating a custom hook over useQuery that accepts all options is a mess. Nobody gets this right because it's complex, and you probably don't want to let users pass all options anyways. I have to constantly talk everybody out of doing this.  \n\n예를 들면 이런거: [https://slash.page/ko/libraries/react/react-query/src/hooks/usesuspendedquery.i18n/](https://slash.page/ko/libraries/react/react-query/src/hooks/usesuspendedquery.i18n/)토스에서 useQuery를 확장해서 useSuspendedQuery를 만들었는데 이거 쓰다가 undefined에러 겪었다.\n\n관련 트윗: https://twitter.com/TkDodo/status/1491451513264574501\n\n![[notes/images/FLKwGYRWYA8rUF0.jpeg]]","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5h-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC":{"title":"5h-프론트엔드-라이브러리","content":"하위 노트 참고","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5h1-ni-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80-%EC%9E%90%EB%8F%99-%EC%84%A0%ED%83%9D":{"title":"5h1-ni-패키지-매니저-자동-선택","content":"https://github.com/antfu/ni\n\nnpm, yarn, pnpm의 lockfile에 맞춰서 알아서 패키지 매니저 실행해줌. 프로젝트마다 다른 패키지 매니저를 사용해야 할 때 유용함.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5i-SSR%EC%8B%9C-%EC%BA%90%EC%8B%9C-%EC%A3%BC%EC%9D%98":{"title":"5i. SSR시 캐시 주의","content":"\n개인화된 페이지를 렌더링하는 경우 캐싱을 하면 안 된다.\n\n캐싱할 페이지와 아닌 페이지를 명확히 구분해야 성능과 보안에서 유리하다.\n\n블로그같은 게시판 형태는 어드민 페이지를 따로 구축하는게 좋다. 특정 path이하는 캐싱하지 않도록 middleware에서 설정하면 된다. `pragma`와 `cache-control` 헤더로.\n\nnextjs에는 [Route Segment Control](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config) 관련해서 캐시 설정을 할 수 있다.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5j-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%8A%A4%EC%BC%88%EB%A0%88%ED%86%A4%EC%9D%80-200ms-%EC%9D%B4%EC%83%81%EC%9D%BC-%EB%95%8C":{"title":"5j-프론트엔드-스켈레톤은-200ms-이상일-때","content":"https://tech.kakaopay.com/post/skeleton-ui-idea/\n\n\u003e `DeferredComponent` 내부의 지연 시간을 200ms으로 잡았기 때문에, 응답 지연이 100ms인 경우에는 스켈레톤을 보여주는 대신 사용자에게 잠시 빈 화면이 노출된 뒤 화면이 제공됩니다. 응답 지연이 1000ms인 경우에는 200ms 동안은 빈 화면이 뜨고 나머지 800ms 동안 스켈레톤이 노출됩니다. 제가 느끼기엔 200ms의 하얀 화면이 그리 어색하게 느껴지지는 않는데, 여러분들은 어떠신가요?\n\u003e\n\u003e 물론 이렇게 지연 시간을 설정한 경우에도 덜그럭 거리는 스켈레톤 뷰를 완벽히 피할수는 없습니다. 예컨데 200ms까지 스켈레톤을 보여주지 않게끔 설정한 화면이 있다고 가정하였을 때, 만약 사용자에게 API 응답이 250ms, 또는 300ms만에 도착했다면 50~100ms 동안 노출될 스켈레톤이 사용자에게 똑같이 덜그럭 거리는 느낌을 주게 되겠죠.\n\u003e\n\u003e 그렇다면 이런 지연된 스켈레톤이 정말 아무 의미가 없을까요?\n\u003e \n\u003e ...\n\u003e \n\u003e 지금 이야기중인 이 서비스에서는 대략 90%의 사용자들이 296ms 이내에 응답을 받는다고 합니다. 이 수치를 토대로 생각해보면 **스켈레톤을 200ms 지연시킬 경우 전체 사용자 중 75%는 기존에 느끼던 덜그럭거림을 느끼지 않을 수 있지만, 기존에 덜그럭거림을 느끼지 못하던 15%의 사용자들은 덜그럭거리는 스켈레톤 뷰를 보게 된다**는 생각을 해볼 수 있을 것 같습니다.\n\u003e\n\u003e(물론 실 서비스에서는 다양한 시나리오를 세워보고 고민하며, 실험과 검증을 통해 지속적으로 개선 프로세스를 진행해야겠지만) 위 가설이 참이여서 전체 사용자의 75%가 느끼던 덜그럭거림을 덜어내고 15%의 사용자에게만 덜그럭거림을 느끼게 한다면 마냥 손해보는 장사는 아닐 수 있겠다는 생각이 듭니다.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5k-why-functional-programming-matters":{"title":"5k. Why Functional Programming Matters","content":"\n\nhttps://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf\n\n![[notes/images/whyfp90.pdf]]","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5l-javascript-%EA%B9%8A%EC%9D%80%EB%B3%B5%EC%82%AC-structured-clone":{"title":"5l. JavaScript 깊은복사 structuredClone","content":"\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/structuredClone","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5m-promise-%EA%B4%80%EB%A0%A8-eslint-rules":{"title":"5m. promise 관련 eslint rules","content":"\nhttps://twitter.com/tommoor/status/1675150188908822530?s=46\u0026t=WWPMzoEtNZZ_eqp7T45DPQ\n\n![[notes/images/Pasted image 20230801152504.png]]\n\n```\n// .eslintignore\n*.js\n```\n\n```json\n// .eslintrc.json\n{\n  \"parser\": \"@typescript-eslint/parser\",  \n  \"parserOptions\": {  \n    \"project\": [\"./tsconfig.json\"]  \n  },\n  \"rules\": {\n    \"@typescript-eslint/no-floating-promises\": \"error\",  \n    \"@typescript-eslint/await-thenable\":\"error\",  \n    \"@typescript-eslint/no-misused-promises\": \"error\"\n  }\n}\n```","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5m1-tsconfig-%EC%B6%94%EC%B2%9C%EC%84%A4%EC%A0%95":{"title":"5m1-tsconfig-추천설정","content":"\nhttps://twitter.com/mattpocockuk/status/1686783013877694482?s=46\u0026t=WWPMzoEtNZZ_eqp7T45DPQ\n\n```\n{\n  \"compilerOptions\": {\n    \"noUncheckedIndexedAccess\": true\n  }\n}\n```","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5n-react-native-naver-map-%EC%B5%9C%EC%8B%A0":{"title":"5n-react-native-naver-map-최신","content":"![[notes/images/Pasted image 20230828095541.png]]\nhttps://github.com/zerocho/react-native-naver-map","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5o-%EC%8A%A4%ED%94%84%EB%A7%81":{"title":"5o-스프링","content":"","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5o1-auto-commit-false":{"title":"5o1. Hikari를 사용할 때 auto commit을 false로 설정하자","content":"https://stackoverflow.com/a/69695930\n\n\u0008`@Transactional`로 트랜잭션의 범위를 설정하면 transaction을 시작할 때 auto commit 옵션을 껏다가 query를 수행한 뒤 다시 켜진다.\n\nHikariCP는 auto-commit의 기본값이 true이기 때문에 Spring Boot에서 별다른 설정을 하지 않으면 매 트랜잭션마다 auto commit 옵션에 대한 쿼리를 수행하는 오버헤드가 발생한다.\n\n아래처럼 auto-commit을 false로 설정하자.\n\n```application.yaml\nspring:\n  datasource:\n    hikari:\n      auto-commit: false\n```\n\ncf. open-in-view도 false로 설정하자: https://backendhance.com/en/blog/2023/open-session-in-view/#should-i-disable-osiv","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5o2-rfc-7807":{"title":"5o2-rfc-7807","content":"https://datatracker.ietf.org/doc/html/rfc7807\n\nSpring 6.0부터 Spring MVC에서 RFC 7807을 지원한다고 함.\n\nhttp 에러의 전세계 표준 포맷이 되겠다.\n\nhttps://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-rest-exceptions.html\n\n`ProblemDetail` 클래스 어떻게 쓰는지 알아야겠네.\n\nhttps://www.baeldung.com/spring-boot-custom-webflux-exceptions#how-to-implement-problemdetail-rfc-7807-exception\n\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ProblemDetail.html\n\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5o3-spring-boot-release-notes":{"title":"5o3-spring-boot-release-notes","content":"https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes\n\nmigration은 문서 보면서: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide\n\n\n## Spring Boot 3.2\n\nSpring Framework 6.1에 있는 `RestClient`를  Spring Boot 3.2에서 지원함: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.2-Release-Notes#restclient-support\n\n### Virtual Thread\n\nVirtual Thread 지원, Java 21 이상: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.2-Release-Notes#support-for-virtual-threads\n\nProject Loom이 드디어! https://spring.io/blog/2023/09/09/all-together-now-spring-boot-3-2-graalvm-native-images-java-21-and-virtual\n\nJava 21이 2023년 9월에 LTS가 되었구나\n\n`spring.threads.virtual.enabled=true`\n\nProject Loom이랑 GraalVM 같이 쓰면 엄청 좋나보네\n\nVirtual Thread 관련 https://openjdk.org/jeps/444 읽기\n\n\u003eMost languages that have adopted syntactic coroutines have done so due to an inability to implement user-mode threads (e.g., Kotlin), legacy semantic guarantees (e.g., the inherently single-threaded JavaScript), or language-specific technical constraints (e.g., C++). These limitations do not apply to Java.\n\n개쩐다\n\n### misc\n\nJWT는 `JwtDecoder`나 `ReactiveJwtDecoder` 쓰면 되는구나\n\n\n\n\n## Spring Boot 3.1\n\nhttps://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.1-Release-Notes#testcontainers\n\ntestcontainers 지원, 개발할 때 사용하기 편해진다\n\n\n\nhttps://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.1-Release-Notes#auto-configuration-for-spring-authorization-server\n\noauth2 authorization server 생겼었구나\n\n\n\nhttps://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2023.0-%28Ullman%29-Release-Notes#scroll-api\n\nSpring Data Scroll API?\n\nScrolling supports two flavors:\n- Offset-based scrolling applying limit/offset in queries.\n- Keyset-based scrolling leveraging index support and sorting to retrieve sorted query sub-results\nhttps://www.baeldung.com/spring-data-jpa-scroll-api\n\nkeyset-based scrolling 사용하면 배치에서 유용할지도?\n\n\n\nhttps://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2023.0-%28Ullman%29-Release-Notes#spring-data-jpa-introduces-hql-and-jpql-parser\n\n`@Query`로 커스텀 쿼리 작성한 메서드에 `Sort` 객체로 순서를 정할 수 있다. `Pageable` 객체도 return할 수 있음\n\n\n\n\n\n\n\n\n\n\n\n\n## Spring Boot 3.0\n\n### Spring Data 2022.0\n\n- `GenericJackson2JsonRedisSerializer`, `Jackson2JsonRedisSerializer`\n    - redis에 serialize/deserialize할 때 이거 썼으면 됐었구나\n\n\n\nhttps://github.com/spring-projects/spring-framework/wiki/What's-New-in-Spring-Framework-6.x\n\n6.1\n\n- Reactive `@Scheduled` methods (including Kotlin coroutines); see [22924](https://github.com/spring-projects/spring-framework/pull/29924).\n    - 오.. 이거 비동기로 도는건 유용하겠다\n- Spring MVC and WebFlux now have built-in method validation support for controller method parameters with `@Constraint` annotations. That means you no longer need `@Validated` at the controller class level to enable method validation via AOP proxy. Built-in method validation is layered on top of the existing argument validation for model attribute and request body arguments. The two are more tightly integrated and coordinated, e.g. avoiding cases with double validation. See [Upgrading to 6.1](https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-6.x#web-applications) for migration details, and umbrella issue [30645](https://github.com/spring-projects/spring-framework/issues/30645) for all related tasks and feedback.\n    - 더 이상 `@Validated` 안 붙여도 되나!\n- New `RestClient`, a synchronous HTTP client that offers an API similar to `WebClient`, but sharing infrastructure with the `RestTemplate`. See [29552](https://github.com/spring-projects/spring-framework/issues/29552).\n    -  `RestClient`라는게 새로 생겼네\n- Support for recording asynchronous events with `@RecordApplicationEvents`. See [30020](https://github.com/spring-projects/spring-framework/pull/30020).\n    - Record events from threads other than the main test thread.\n    - Assert events from a separate thread – for example with Awaitility.\n    - 비동기 코드 테스트할 때 유용하겠다\n\n6.0\n\n- GraalVM으로 native binary 생성하는거 신기하네.. 쓸 수 있나? 성능 좋나?\n    - serverless 코드 작성할 때 이걸로 하면 좋겠네\n- 하이버네이트 6.1 지원\n- `PathPatternParser` used by default (with the ability to opt into `PathMatcher`).\n    - `PathMatcher` 대신에 `PathPatternParser` 써야겠네\n- 지표 추적해야 할 때 Micrometer 적극 활용하자\n\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5p-%EB%B6%80%ED%95%98-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EA%B5%AC":{"title":"5p. 부하 테스트 도구","content":"https://gist.github.com/denji/8333630\n\n1. 로컬에서 cli로 간단하게 실행할 수 있다.\n2. 다양한 시각적 report를 쉽게 만들 수 있다.\n\n위 2가지 기준에선 [Vegeta](https://github.com/tsenart/vegeta)가 제일 낫다.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5q-%EC%A0%95%EA%B7%9C%EC%8B%9D%EC%9C%BC%EB%A1%9C-%ED%95%9C%EA%B8%80-%EB%8F%8C%EB%A6%B4-%EB%95%8C-%EC%A3%BC%EC%9D%98-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C":{"title":"5q. 정규식으로 한글 돌릴 때 주의 (유니코드)","content":"윈도우와 맥의 한글 처리 방식이 달라서 (두 방식 모두 표준) normalize를 한 뒤에 검사해야 한다(=NFC 정규화). https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n\nhttps://x.com/heliatalk/status/1709790259842859234?s=46\u0026t=WWPMzoEtNZZ_eqp7T45DPQ\n\n`ㄱ-힣` 으로 하면 한글 뿐만 아니라 그 사이에 있는 다른 문자들도 패턴에 포함되므로 `ㄱ-ㅣ가-힣`을 써야 한다.\n\n[unicode aware mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode#unicode-aware_mode)에서는 정규식 안에 unicode character class를 지정할 수 있다. `\\p{sc=Hangul}` 이런 형태로. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape\n\n`sc`는 `Script`를 줄인것. `\\p{Script=Hangul}`도 가능.\n\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5r-monorepo-tools":{"title":"5r. monorepo.tools","content":"https://monorepo.tools/\n\n모노레포 설명 잘 되어있는 곳.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5s-ux-pattern":{"title":"5s. UX Pattern","content":"https://diby.io/upa","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5t-aws":{"title":"5t. AWS","content":"","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5t1-aws-lambda-graalvm":{"title":"5t1. Aws Lambda, GraalVM","content":"https://www.formkiq.com/blog/tutorials/aws-lambda-graalvm/\n\nkotlin으로 작성한 프로그램을 graalvm으로 컴파일해서 lambda 위에서 돌리면 좋겠는데\n\nSpring Cloud Function도 참고해보자\n\n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html\n\nhttps://gvart.dev/post/2023/02/native_spring_boot_aws_lambda/\n\njdbc 직접 쓰거나 jdbi 쓰기.\n- https://www.baeldung.com/java-jdbc\n- https://www.baeldung.com/jdbi\n\n\nSpring 대신 https://quarkus.io/ ??\n\nhttps://quarkus.io/guides/aws-lambda\n\nhttps://quarkus.io/guides/kotlin\n\nhttps://quarkus.io/guides/aws-lambda-http\n\n\n여기에 예시 코드 다 있네\n\nhttps://docs.aws.amazon.com/lambda/latest/dg/java-samples.html\n\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5t1-vpc-endpoint-gateway":{"title":"5t1. VPC Endpoint Gateway","content":"VPC Endpoint에는 interface 타입과 gateway 타입이 있다. interface는 월 $7정도 비용이 나가지만 gateway는 비용이 들지 않음.\n\ngateway는 s3와 dynamodb에만 사용 가능하다. VPC 내부의 ec2, lambda등에서 s3와 dynamod에 접근할 때 발생하는 NAT 트래픽 비용을 아껴줄 수 있으므로 기본으로 사용하는게 좋다.\n\n### 참조\n\n- https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/vpc-endpoints-dynamodb.html\n- https://ngoyal16.medium.com/vpc-endpoints-or-nat-gateway-d78430b15b1e#:~:text=A%20Gateway%20Endpoints%20is%20free,services%20with%20a%20public%20API.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5u-kotlin":{"title":"5u. kotlin","content":"","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5u1-kotlin-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0":{"title":"5u1. Kotlin 업데이트 따라잡기","content":"1.4버전까지는 책 [Atomic Kotlin](https://www.atomickotlin.com/)으로 커버했으므로 1.5 변경사항부터 유용해보이는걸 정리해보자.\n\n\nTODO: 1.5.2부터 추가\n\n\n## [# What's new in Kotlin 1.9.20](https://kotlinlang.org/docs/whatsnew1920.html)\n\n### `java-test-fixtures` 플러그인으로 생성한 testFixtures sourceSet에서 main의 internal 클래스에 접근할 수 있다\n\nhttps://kotlinlang.org/docs/whatsnew1920.html#support-for-test-fixtures-to-access-internal-declarations\n\n### `enumValues()` 대신 `enumEntries()` (experimental)\n\nenum을 generic으로 받아서 사용할 때 쓴다. 역시 배열이 아니라 List를 사용하기 때문에 성능 이슈가 없다고 한다.\n\nhttps://kotlinlang.org/docs/whatsnew1920.html#replacement-of-the-enum-class-values-generic-function\n\n```kotlin\nenum class RGB { RED, GREEN, BLUE }\n\n@OptIn(ExperimentalStdlibApi::class)\ninline fun \u003creified T : Enum\u003cT\u003e\u003e printAllValues() {\n    print(enumEntries\u003cT\u003e().joinToString { it.name })\n}\n\nprintAllValues\u003cRGB\u003e()\n// RED, GREEN, BLUE\n```\n\n\n\n## [What's new in Kotlin 1.9.0](https://kotlinlang.org/docs/whatsnew19.html)\n\n### `enum`의 `values()` 대신 `entries` property 사용\n\nhttps://kotlinlang.org/docs/whatsnew19.html#stable-replacement-of-the-enum-class-values-function\n\nJava의 `values()`는 배열을 return하고, 배열을 쓰면 성능 문제가 생길 수 있다고 함.\n\n대신 entries 프로퍼티를 쓰면 된다. stable\n\n```kotlin\nenum class Color(val colorName: String, val rgb: String) {\n    RED(\"Red\", \"#FF0000\"),\n    ORANGE(\"Orange\", \"#FF7F00\"),\n    YELLOW(\"Yellow\", \"#FFFF00\")\n}\n\nfun findByRgb(rgb: String): Color? = Color.entries.find { it.rgb == rgb }\n```\n\n\n### `data object`가 stable\n\nhttps://kotlinlang.org/docs/whatsnew19.html#stable-data-objects-for-symmetry-with-data-classes\n\n`sealed`와 함께 사용하면 좋음.\n\n```kotlin\nsealed interface ReadResult\ndata class Number(val number: Int) : ReadResult\ndata class Text(val text: String) : ReadResult\ndata object EndOfFile : ReadResult\n\nfun main() {\n    println(Number(7)) // Number(number=7)\n    println(EndOfFile) // EndOfFile\n}\n```\n\n### inline value class의 생성자에 body를 쓸 수 있다 (stable)\n\n1.8.20에서 추가한 기능. 이제 stable이고 기본으로 사용할 수 있음\n\n```kotlin\n@JvmInline\nvalue class Person(private val fullName: String) {\n    // Allowed since Kotlin 1.4.30:\n    init {\n        check(fullName.isNotBlank()) {\n            \"Full name shouldn't be empty\"\n        }\n    }\n    // Allowed by default since Kotlin 1.9.0:\n    constructor(name: String, lastName: String) : this(\"$name $lastName\") {\n        check(lastName.isNotBlank()) {\n            \"Last name shouldn't be empty\"\n        }\n    }\n}\n```\n\n\n### `..\u003c` 열린 구간 operator가 stable\n\n\n\n\n## [What's new in Kotlin 1.8.20](https://kotlinlang.org/docs/whatsnew1820.html)\n\n### inline class의 생성자에 body 추가 (experimental)\n\n이전까지는 생성자만 사용할 수 있고 생성자 내부에서 어떤 일을 할 수 없었다. 이제 primary constructor를 위한 `init {}`과 secondary constructor에 body를 사용할 수 있다.\n\n```kotlin\n@JvmInline\nvalue class Person(private val fullName: String) {\n// Allowed since Kotlin 1.4.30:\n    init {\n        check(fullName.isNotBlank()) {\n            \"Full name shouldn't be empty\"\n        }\n    }\n// Preview available since Kotlin 1.8.20:\n    constructor(name: String, lastName: String) : this(\"$name $lastName\") {\n        check(lastName.isNotBlank()) {\n            \"Last name shouldn't be empty\"\n        }\n    }\n}\n```\n\n### kapt를 사용해도 IR Backend를 사용할 수 있는 옵션이 기본으로 적용\n\n`kapt.use.jvm.ir=true` 없어도 됨\n\n\n### Base64 인코딩 지원 (experimental)\n\nhttps://kotlinlang.org/docs/whatsnew1820.html#support-for-base64-encoding\n\n\n\n\n\n\n## [What's new in Kotlin 1.8.0](https://kotlinlang.org/docs/whatsnew18.html)\n\nK2 컴파일러 작업하느라 언어 변경사항이 많지 않은듯.\n\n### Java Optional 객체에 추가한 확장함수가 stable\n\n1.7.0에 experimental이었던 기능\n\n\n\n## [What's new in Kotlin 1.7.20](https://kotlinlang.org/docs/whatsnew1720.html)\n\n### 열린 구간(open-ended) operator `..\u003c` 추가 (experimental)\n\n```kotlin\nwhen (value) {\n    in 0.0..\u003c0.25 -\u003e // First quarter\n    in 0.25..\u003c0.5 -\u003e // Second quarter\n    in 0.5..\u003c0.75 -\u003e // Third quarter\n    in 0.75..1.0 -\u003e  // Last quarter  \u003c- Note closed range here\n}\n```\n\n\n### inline class에 generic 추가 (experimental)\n\n```kotlin\n@JvmInline\nvalue class UserId\u003cT\u003e(val value: T)\n\nfun compute(s: UserId\u003cString\u003e) {} // Compiler generates fun compute-\u003chashcode\u003e(s: Any?)\n```\n\n\n### kapt도 IR Backend를 사용할 수 있다 (experimental)\n\n코틀린 컴파일러 백엔드\n\ngradle.properties\n\n```\nkapt.use.jvm.ir=true\n```\n\n\n\n## [What's new in Kotlin 1.7.0](https://kotlinlang.org/docs/whatsnew18.html)\n\n### Kotlin K2 컴파일러 alpha버전 릴리즈\n\nhttps://kotlinlang.org/docs/whatsnew17.html#new-kotlin-k2-compiler-for-the-jvm-in-alpha\n\n기존 컴파일러보다 2배 이상 빠르네\n\n`-Xuse-k2`\n\n### inline class에 delegation을 쓸 수 있다\n\n```kotlin\ninterface Bar {\n    fun foo() = \"foo\"\n}\n\n@JvmInline\nvalue class BarWrapper(val bar: Bar): Bar by bar\n\nfun main() {\n    val bw = BarWrapper(object: Bar {})\n    println(bw.foo())\n}\n```\n\n\n### 타입 파라미터에 `_` 로 추론을 할 수 있다\n\n```kotlin\nabstract class SomeClass\u003cT\u003e {\n    abstract fun execute(): T\n}\n\nclass SomeImplementation : SomeClass\u003cString\u003e() {\n    override fun execute(): String = \"Test\"\n}\n\nclass OtherImplementation : SomeClass\u003cInt\u003e() {\n    override fun execute(): Int = 42\n}\n\nobject Runner {\n    inline fun \u003creified S: SomeClass\u003cT\u003e, T\u003e run(): T {\n        return S::class.java.getDeclaredConstructor().newInstance().execute()\n    }\n}\n\nfun main() {\n    // T is inferred as String because SomeImplementation derives from SomeClass\u003cString\u003e\n    val s = Runner.run\u003cSomeImplementation, _\u003e()\n    assert(s == \"Test\")\n\n    // T is inferred as Int because OtherImplementation derives from SomeClass\u003cInt\u003e\n    val n = Runner.run\u003cOtherImplementation, _\u003e()\n    assert(n == 42)\n}\n```\n\n\n### Definitely non-nullable types (stable)\n\ngeneric 타입 파라미터에 nullable 타입을 넣어도 매개변수에 null값이 들어오지 않도록 강제할 수 있다. `T \u0026 Any`\n\n```kotlin\nfun \u003cT\u003e elvisLike(x: T, y: T \u0026 Any): T \u0026 Any = x ?: y\n\nfun main() {\n    // OK\n    elvisLike\u003cString\u003e(\"\", \"\").length\n    // Error: 'null' cannot be a value of a non-null type\n    elvisLike\u003cString\u003e(\"\", null).length\n\n    // OK\n    elvisLike\u003cString?\u003e(null, \"\").length\n    // Error: 'null' cannot be a value of a non-null type\n    elvisLike\u003cString?\u003e(null, null).length\n}\n```\n\n\n### `DeepRecursiveFunction`이 stable\n\n1.4.0에 추가된 `DeepRecursiveFunction`이 stable이 되었다.\n\n`DeepRecursiveFunction` 을 사용하는 재귀함수는 stack을 heap에 쌓기 때문에 깊게 재귀를 들어가도 stack overflow를 피할 수 있다.\n\n```kotlin\nclass Tree(val left: Tree?, val right: Tree?)\n\nval calculateDepth = DeepRecursiveFunction\u003cTree?, Int\u003e { t -\u003e\n    if (t == null) 0 else maxOf(\n        callRecursive(t.left),\n        callRecursive(t.right)\n    ) + 1\n}\n\nfun main() {\n    // Generate a tree with a depth of 100_000\n    val deepTree = generateSequence(Tree(null, null)) { prev -\u003e\n        Tree(prev, null)\n    }.take(100_000).last()\n\n    println(calculateDepth(deepTree)) // 100000\n}\n```\n\n위 예제에서는 10만번을 들어가지만 stack overflow가 발생하지 않는다.\n\n1000이상의 깊이에서는 `DeepRecursiveFunction`을 사용하는걸 추천.\n\n\n### Java의 `Optional` 타입에 대한 확장함수 추가 (experimental)\n\nhttps://kotlinlang.org/docs/whatsnew17.html#new-experimental-extension-functions-for-java-optionals\n\n- getOrNull\n- getOrDefault\n- getOrElse\n- toList\n- toSet\n- asSequence\n- toCollection\n\n\n### 정규표현식에서 group에 이름 짓기\n\n이런게 됐었구나.. JS와 Native에서도 된다고 함.\n\n```kotlin\nfun main() {\n    val regex = \"\\\\b(?\u003ccity\u003e[A-Za-z\\\\s]+),\\\\s(?\u003cstate\u003e[A-Z]{2}):\\\\s(?\u003careaCode\u003e[0-9]{3})\\\\b\".toRegex()\n    val input = \"Coordinates: Austin, TX: 123\"\n    val match = regex.find(input)!!\n    println(match.groups[\"city\"]?.value) // \"Austin\" — by name\n    println(match.groups[2]?.value) // \"TX\" — by number\n}\n```\n\nbackrefernce. 이전에 찾은 값과 동일해야만 매칭이 된다.\n\n```kotlin\nfun backRef() {\n    val regex = \"(?\u003ctitle\u003e\\\\w+), yes \\\\k\u003ctitle\u003e\".toRegex()\n    val match = regex.find(\"Do you copy? Sir, yes Sir!\")!!\n    println(match.value) // \"Sir, yes Sir\"\n    println(match.groups[\"title\"]?.value) // \"Sir\"\n}\n```\n\nreplace에서도 named group을 사용할 수 있음\n\n```kotlin\nfun dateReplace() {\n    val dateRegex = Regex(\"(?\u003cdd\u003e\\\\d{2})-(?\u003cmm\u003e\\\\d{2})-(?\u003cyyyy\u003e\\\\d{4})\")\n    val input = \"Date of birth: 27-04-2022\"\n    println(dateRegex.replace(input, \"\\${yyyy}-\\${mm}-\\${dd}\")) // \"Date of birth: 2022-04-27\" — by name\n    println(dateRegex.replace(input, \"\\$3-\\$2-\\$1\")) // \"Date of birth: 2022-04-27\" — by number\n}\n```\n\n\n### 자바의 SAM 메서드의 첫 번째 매개변수를 코틀린에서  `this`로 받을 수 있는 gradle plugin\n\nhttps://kotlinlang.org/docs/whatsnew17.html#the-sam-with-receiver-plugin-is-available-via-the-plugins-api\n\n```java\npublic @interface SamWithReceiver {}\n\n@SamWithReceiver\npublic interface TaskRunner {\n    void run(Task task);\n}\n```\n\n\n```kotlin\nfun test(context: TaskContext) {\n    val runner = TaskRunner {\n        // Here 'this' is an instance of 'Task'\n\n        println(\"$name is started\")\n        context.executeTask(this)\n        println(\"$name is finished\")\n    }\n}\n```\n\n\n\n\n## [What's new in Kotlin 1.6.20](https://kotlinlang.org/docs/whatsnew1620.html)\n\n### context receiver prototype 추가\n\nReact의 Context API와 유사하네. 아직 prototype이라 production code에서 사용할 수 없음.\n\n```kotlin\ninterface LoggingContext {\n  val log: Logger // This context provides a reference to a logger\n}\n\ncontext(LoggingContext)\nfun startBusinessOperation() {\n  // You can access the log property since LoggingContext is an implicit receiver\n  log.info(\"Operation has started\")\n}\n\nfun test(loggingContext: LoggingContext) {\n  with(loggingContext) {\n    // You need to have LoggingContext in a scope as an implicit receiver\n    // to call startBusinessOperation()\n    startBusinessOperation()\n  }\n}\n```\n\n\n### Definitely non-nullable types (beta)\n\ngeneric 타입 파라미터에 nullable 타입을 넣어도 매개변수에 null값이 들어오지 않도록 강제할 수 있다. `T \u0026 Any`\n\n아직 beta\n\n```kotlin\nfun \u003cT\u003e elvisLike(x: T, y: T \u0026 Any): T \u0026 Any = x ?: y\n\nfun main() {\n    // OK\n    elvisLike\u003cString\u003e(\"\", \"\").length\n    // Error: 'null' cannot be a value of a non-null type\n    elvisLike\u003cString\u003e(\"\", null).length\n\n    // OK\n    elvisLike\u003cString?\u003e(null, \"\").length\n    // Error: 'null' cannot be a value of a non-null type\n    elvisLike\u003cString?\u003e(null, null).length\n}\n```\n\n### 코틀린 인터페이스에 선언한 non-abstract property를 Java에서 default method로 사용할 수 있게 하는 방법 추가\n\n원래는 컴파일러 옵션에 `-Xjvm-default=all-compatibility`를 추가하고 인터페이스에 `@JvmDefaultWithoutCompatibility`를 붙여야만 했었다. 이렇게 하면 새로 추가되는 모든 인터페이스에 `@JvmDefaultWithoutCompatibility`를 붙여줘야 해서 까먹기 쉬웠음.\n\n1.6.20부터는 컴파일러 옵션에 `-Xjvm-default=all` 을 추가해서 모든 interface에 `@JvmDefaultWithoutCompatibility`를 붙일 수 있음. 컴파일러 옵션만 추가하면 non-abstract property를 Java에서 default method로 사용할 수 있다.\n\n\n### 하나의 모듈에 대한 병렬 컴파일 옵션 추가\n\nhttps://kotlinlang.org/docs/whatsnew1620.html#support-for-parallel-compilation-of-a-single-module-in-the-jvm-backend\n\n`-Xbackend-threads`\n\n거대한 single module에 대해서 병렬 컴파일을 하면 속도가 최대 15% 상승할 수 있음.\n\n이미 gradle module로 여러 개의 모듈을 쪼개놓은 상태라면 gradle에서 모듈별로 알아서 병렬로 컴파일하므로 이 옵션을 켜면 오히려 속도가 느려질 수 있다, thread의 context switch때문에.\n\n`kapt`를 사용하고 있으면 적용 못함.\n\n\n### annotation class에 대한 객체 생성 기능이 stable\n\nhttps://kotlinlang.org/docs/whatsnew1620.html#instantiation-of-annotation-classes\n\n\n\n\n## [What's new in Kotlin 1.6.0](https://kotlinlang.org/docs/whatsnew16.html)\n\n### experimental -\u003e stable\n\n- 1.5.30에 추가되었던 `when`절의 sealed, boolean 객체에 대한 경고 처리\n- 1.5.30에 추가되었던 `suspend`함수를 부모타입으로 가질 수 있는 기능\n\n더 이상 experimental이 아니다\n\n### 클래스 타입 파라미터에 대한 어노테이션 추가\n\nhttps://kotlinlang.org/docs/whatsnew16.html#support-for-annotations-on-class-type-parameters\n\n```kotlin\n\n@Target(AnnotationTarget.TYPE_PARAMETER)\nannotation class BoxContent\n\nclass Box\u003c@BoxContent T\u003e {}\n```\n\n\n### `@Repeatable` 어노테이션에 대한 자바 호환성 향상\n\n- `@java.lang.annotation.Repeatable`\n- `@kotlin.annotation.Repeatable`\n\n동일한 어노테이션을 여러 번 선언할 수 있게 해주는 `@Repeatable` 어노테이션. 자바와 코틀린 둘다 있었지만 코틀린 1.6.0 전까지는 자바의 `@Repeatable` 어노테이션을 코틀린에서 인식하지 못했음. 이제는 된다.\n\n\n### `readln(), readlnOrNull()` 함수 추가\n\n|**Earlier versions**|**1.6.0 alternative**|**Usage**|\n|---|---|---|\n|`readLine()!!`|`readln()`|Reads a line from stdin and returns it, or throws a `RuntimeException` if EOF has been reached.|\n|`readLine()`|`readlnOrNull()`|Reads a line from stdin and returns it, or returns `null` if EOF has been reached.|\n\n\n### `typeof\u003cT\u003e()`가 stable\n\n`KType` 객체를 리턴하는 `typeof\u003cT\u003e()`\n\n```kotlin\ninline fun \u003creified T\u003e renderType(): String {\n  val type = typeOf\u003cT\u003e()\n  return type.toString()\n}\n\nfun main() {\n  val fromExplicitType = typeOf\u003cInt\u003e()\n  val fromReifiedType = renderType\u003cList\u003cInt\u003e\u003e()\n}\n```\n\n### collection builder가 stable\n\n`buildMap()`, `buildList()`, `buildSet()` 을 더 이상 opt-in 어노테이션 없이도 사용할 수 있다.\n\n\n### `Regex.splitToSequence(CharSequence)`, `CharSequence.splitToSequence(Regex)`가 stable\n\n\n### Bit rotation 함수가 stable\n\n```kotlin\nval number: Short = 0b10001\nprintln(number\n        .rotateRight(2)\n        .toString(radix = 2)) // 100000000000100\nprintln(number\n        .rotateLeft(2)\n        .toString(radix = 2))  // 1000100\n```\n\n### Kover, 코틀린을 위한 코드 커버리지 툴 (JaCoCo같은거)\n\nhttps://kotlinlang.org/docs/whatsnew16.html#kover-a-code-coverage-tool-for-kotlin\n\ngradle plugin으로 사용할 수 있다. 아직 experimental\n\nJaCoCo에서 잘 처리하지 못했던 inline function등에 대한 처리를 할 수 있음.\n\n\n\n\n## [What's new in Kotlin 1.5.30](https://kotlinlang.org/docs/whatsnew1530.html)\n\n\n### selaed 객체 및 boolean 객체를 `when` 절에서 사용할 때 모든 케이스를 다루지 않으면 \u0008경고가 발생한다 (experimental)\n\n아직까지는 experimental.\n\n`enum` 에는 이미 적용되어 있음.\n\n### `suspend` 함수를 부모 타입으로 가질 수 있다 (experimental)\n\n```kolint\nclass MyClass: suspend () -\u003e Unit {\n  override suspend fun invoke() { TODO() }\n}\n```\n\n함수 객체가 `suspend () -\u003e Unit` 타입을 상속한다\n\n\n### 재귀적인 generic type에 대한 처리 향상\n\nhttps://kotlinlang.org/docs/whatsnew1530.html#improvements-to-type-inference-for-recursive-generic-types\n\n언젠가 쓸 일이 있겠지\n\n### nullability 어노테이션의 경고 수준을 정할 수 있다\n\n무시할건지, warn으로 경고로 처리할건지, strict로 에러로 처리할건지\n\nhttps://kotlinlang.org/docs/whatsnew1530.html#improved-nullability-annotation-support-configuration\n\n\n### 정규표현식과 매치되는 문자열의 index 위치를 검사하는 메서드 추가\n\nhttps://kotlinlang.org/docs/whatsnew1530.html#splitting-regex-to-a-sequence\n\n- `Regex.matchAt(input: CharSequence, index: Int): MatchResult?`\n- `Regex.matchesAt(input: CharSequence, index: Int): Boolean`\n\n`input`에서 `index`위치에 정규표현식을 만족하는 문자열이 있는지.\n\n\n### `Regex.splitToSequence()` 추가 (`split()`의 lazy 버전)\n\n`List`가 아니라 `Sequence`를 리턴한다.\n\n\n\n## [What's new in Kotlin 1.5.20](https://kotlinlang.org/docs/whatsnew1520.html)\n\n### JSpecify nullness 어노테이션 지원\n\nhttps://kotlinlang.org/docs/whatsnew1520.html#support-for-jspecify-nullness-annotations\n\n자바 코드에 JSpecify 써보면 괜찮겠다. 패키지나 클래스에 `@NullMarked` 어노테이션 붙이면 `@Nullable` 어노테이션이 붙어있지 않은 매개변수와 리턴타입은 not null이라고 표현할 수 있음. https://jspecify.dev/docs/user-guide, https://github.com/jspecify/jspecify/blob/eff8f186a7036d5f18108d27e09011a4f1198f05/src/main/java/org/jspecify/annotations/NullMarked.java#L115\n\n\n## [What's new in Kotlin 1.5.0](https://kotlinlang.org/docs/whatsnew15.html)\n\n### `@JvmRecord`\n\n`data class`에 `@JvmRecord` 어노테이션을 붙이면 자바에서 record 클래스처럼 사용할 수 있음.\n\n### `sealed interface`\n\n`sealed class`와 동일함. 이 인터페이스는 같은 파일 내에서만 implement 할 수 있다. 인터페이스를 구현하는 장소가 하나의 파일로 제한되므로 컴파일러가 구현의 모든 케이스를 검증할 수 있어서 `when`에서 모든 케이스를 다루는지 다루지 않는지 검사할 수 있다.\n\n상속을 피하라는 이유중 하나는 누가 어디서 어떻게 상속하는지 추적이 안 되어서 자바의 `instanceof`를 사용해 타입으로 분기하는 코드가 변경에 취약하다는 것이다. 하지만 컴파일러가 상속의 모든 케이스를 알 수 있어서 코딩할 때 컴파일러의 도움을 받을 수 있다면 타입으로 분기하는 코드를 안전하게 사용할 수 있다.\n\n패턴매칭(`when`)을 활용하기 편해짐.\n\n### `sealed class`를 상속한 클래스를 선언할 수 있는 범위가 파일에서 패키지 단위로 넓어졌다\n\n동일한 파일에서 동일한 컴파일 단위(=패키지, 동일한 디렉토리)로 범위가 넓어졌다. 좋네.\n\n### inline classes\n\n`value class Password(val s: String)`\n\n프로퍼티를 하나만 갖는 value class를 선언할 수 있다. `typealias`와 유사한 용도로 사용하면 된다. 어떤 타입을 다른 이름으로 선언해서 도메인 언어를 더 풍부하게 사용하고 싶을 때 `value class`를 사용하면 됨. `typealias`와 다른 점은 다른 타입을 할당할 수 없다는 점이다. https://kotlinlang.org/docs/inline-classes.html#inline-classes-vs-type-aliases\n\n```kotlin\nvar password = Password(\"don't do this on production\")\npassword = \"plain string\" // 불가능\n```\n\ninline class라고 불리는 이유는 실행시간(runtime)에 `Password`라는 클래스의 인스턴스를 생성하는게 아니기 때문이다.\n\n```kotlin\nclass UseInlineClass {  \n    fun useInlineClass() {  \n        val inlineClass = InlineClass(\"inline class\")  \n        println(inlineClass.getValue())  \n  \n        val basicClass = BasicClass(\"basic class\")  \n        println(basicClass.getValue())  \n    }  \n}\n```\n\n위 코드를 컴파일하고 자바 코드로 디컴파일하면 아래처럼 나온다.\n\n```java\npublic final class UseInlineClass {  \n   public final void useInlineClass() {  \n      String inlineClass = InlineClass.constructor-impl(\"inline class\");  \n      System.out.println(InlineClass.getValue-impl(inlineClass));  \n      \n      BasicClass basicClass = new BasicClass(\"basic class\");  \n      System.out.println(basicClass.getValue());  \n   }  \n}\n```\n\n`new`로 클래스를 만드는게 아니라 `constructor-impl`함수를 호출해서 `String`을 받는다. `constructor-impl`함수는 아래처럼 생겼음.\n\n```java\npublic final class InlineClass {\n  ...\n  \n@NotNull  \n  public static String constructor_impl/* $FF was: constructor-impl*/(@NotNull String value) {  \n     Intrinsics.checkNotNullParameter(value, \"value\");  \n     return value;  \n  }\n  \n  ...\n}\n```\n\n함수 호출을 하는 오버헤드는 있지만 객체 생성을 하지 않기 때문에 추가로 메모리를 사용하지 않는다.\n\n최범균님의 책에서는 id클래스를 자바 기본 타입인 `Long`이 아니라 엔티티별로 id 클래스를 만들어서 사용한다. id를 구분할 때 타입으로 구분할 수 있어서 함수 매개변수에 여러 개의 id를 넣어야 할 때 실수하지 않을 수 있지만 `@GeneratedValue(strategy = GenerationType.IDENTITY)`를 사용할 수 없어서 auto increment를 적용할 수 없었기 때문에 사용하지 못했다.\n\n아래처럼 `@Id`를 `Long`타입에 놓고 property에서 value class를 리턴하도록 하면 위 목적을 달성할 수 있음\n\n```kotlin\n@MappedSuperclass  \nabstract class BaseEntity\u003cT\u003e(  \n    @field:Transient  \n    protected var idConstructor: (id: Long) -\u003e T,  \n) {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    @Column(name = \"id\")  \n    val _id: Long = 0L  \n    val id: T  \n        get() = idConstructor(_id)\n    \n    /**  \n     * 자식 클래스에서 postLoad에서 idConstructor를 넣어줘야 id property를 조회할 때 에러가 발생하지 않는다.  \n     * 예)  \n     *   override fun postLoad() {\n     *     this.idConstructor = ::ArticleId\n     *   }\n     **/\n     @PostLoad  \n     protected abstract fun postLoad()  \n}\n```\n\n\n### SAM(Single Abstract Method) adapters via invokedynamic\n\nhttps://kotlinlang.org/docs/whatsnew15.html#sam-adapters-via-invokedynamic\n\nSAM 인터페이스를 구현하는 객체에 대해서 컴파일 할 때 wrapper 클래스를 생성하지 않고 `invokedynamic` jvm instruction을 사용한다.\n\nkotlin lambda에 대해서도 `invokedynamic`을 사용할 수 있긴 하지만 아직 experimental.\n\n### 자바의 nullability 어노테이션에 대한 처리 향상\n\nhttps://kotlinlang.org/docs/whatsnew15.html#improvements-to-handling-nullability-annotations\n\n코틀린에서 자바로 작성된 클래스를 사용할 때 `@Nullable`등 Java 코드에 붙어있는 nullability 관련 어노테이션을 의미있는 정보로 처리해준다.\n\n지원하는 nullability annotations: https://kotlinlang.org/docs/java-interop.html#nullability-annotations\n\n\n### locale에 영향받지 않는 대소문자 변환 함수 추가\n\nhttps://kotlinlang.org/docs/whatsnew15.html#stable-locale-agnostic-api-for-upper-lowercasing-text\n\nString\n\n|**Earlier versions**|**1.5.0 alternative**|\n|---|---|\n|`String.toUpperCase()`|`String.uppercase()`|\n|`String.toLowerCase()`|`String.lowercase()`|\n|`String.capitalize()`|`String.replaceFirstChar { it.uppercase() }`|\n|`String.decapitalize()`|`String.replaceFirstChar { it.lowercase() }`|\n\nChar\n\n|**Earlier versions**|**1.5.0 alternative**|\n|---|---|\n|`Char.toUpperCase()`|`Char.uppercaseChar(): Char`  \u003cbr\u003e`Char.uppercase(): String`|\n|`Char.toLowerCase()`|`Char.lowercaseChar(): Char`  \u003cbr\u003e`Char.lowercase(): String`|\n|`Char.toTitleCase()`|`Char.titlecaseChar(): Char`  \u003cbr\u003e`Char.titlecase(): String`|\n\n\n### Path 표현할 때 나누기(`/`) operator를 사용할 수 있음\n\nhttps://kotlinlang.org/docs/whatsnew15.html#stable-path-api\n\n```\n// construct path with the div (/) operator\n\nval baseDir = Path(\"/base\")\nval subDir = baseDir / \"subdirectory\" // list files in a directory\n\nval kotlinFiles: List\u003cPath\u003e = Path(\"/home/user\").listDirectoryEntries(\"*.kt\")\n```\n\n예전부터 됐었나본데 1.5.0에서 stable이 되었다.\n\n\n### 문자 타입(Char)에 메서드 추가\n\n유용한 메서드들이 있네. 숫자인지 문자인지 구분한다든지 \n\nhttps://kotlinlang.org/docs/whatsnew15.html#new-api-for-getting-a-char-category-now-available-in-multiplatform-code\n\n\n### `Collections.firstNotNullOf()`\n\nhttps://kotlinlang.org/docs/whatsnew15.html#new-collections-function-firstnotnullof\n\n`mapNotNull().first()`를 합쳐놓았다.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5v-cli-tools":{"title":"5v-cli-tools","content":"","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5v1-tlm-cli%EC%97%90%EC%84%9C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94-copilot":{"title":"5v1. tlm: cli에서 작동하는 copilot","content":"https://github.com/yusufcanb/tlm\n\nhttps://news.hada.io/topic?id=13919\n\u003e - CLI에 대해서 자연어로 요청하면 명령을 생성해주는 코파일럿 도구  \n    `$ tlm suggest 'list all network interfaces but only their ip addresses'`  \n    `\u003e ip addr show | grep -oP 'inet \\K[\\d.]+`\n\u003e - API Key 나 인터넷 연결 필요없음\n\u003e - 맥/리눅스/윈도우에서 동작\n\u003e - 자동 Shell 감지\n\u003e - 원라인 명령 생성 및 명령에 대한 설명도 해줌","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5w-%EB%A1%9C%EC%BB%AC-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-https":{"title":"5w. 로컬 개발환경에서 https","content":"https://anchor.dev/blog/introducing-lcl-host","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/5x-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%85%B8%ED%8A%B8%EB%B6%81":{"title":"5x. 자바스크립트 노트북","content":"https://github.com/observablehq/framework","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/6-%ED%95%99%EB%AC%B8%EC%9D%98-%EC%9E%90%EC%84%B8":{"title":"6-학문의-자세","content":"http://home.ewha.ac.kr/~oookwhan/essay/essay2-toyoung.htm\n\n![[notes/images/essay.pdf]]","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/7-ghost%EC%97%90-code-highlight":{"title":"7-ghost에-code-highlight","content":"https://ghost.org/tutorials/code-snippets-in-ghost/\n\n### Post header\n\n```html\n\u003clink rel=\"stylesheet\" href=\"https://unpkg.com/prism-themes@1.9.0/themes/prism-one-light.css\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\" /\u003e\n```\n\n### Post footer\n\n```html\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js\" integrity=\"sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"\u003e\u003c/script\u003e\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js\" integrity=\"sha512-fTl/qcO1VgvKtOMApX2PdZzkziyr2stM65GYPLGuYMnuMm1z2JLJG6XVU7C/mR+E7xBUqCivykuhlzfqxXBXbg==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"\u003e\u003c/script\u003e\n```","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/8-%EC%84%9C%EB%B2%84-%EC%97%86%EC%9D%B4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94-pdftool":{"title":"8-서버-없이-브라우저에서-작동하는-pdftool","content":"https://www.pdftool.org/ko\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/images/5x-elysia-bun-web-framwork":{"title":"5x-elysia-bun-web-framwork","content":"https://elysiajs.com/\n\n타입스크립트로 Type Safety를 마법같이 챙기는게 인상적이다.\n\n간단한 웹 서버가 필요할 때 써보면 좋을듯.\n\n문서화도 엄청 편하다고 하니까.","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/notes/images/6-%EB%9D%BC%EC%9D%B4%ED%8A%B8%EB%AA%A8%EB%93%9C%EA%B0%80-%EB%88%88%EC%97%90-%EC%A2%8B%EB%8B%A4":{"title":"6-라이트모드가-눈에-좋다","content":"https://www.youtube.com/watch?v=m_67BIzkN-w\n\n동공이 좁아지면 초점 잡기가 쉬운 이유 [https://www.sony.co.kr/electronics/what-is-aperture-depth-of-field](https://www.sony.co.kr/electronics/what-is-aperture-depth-of-field)사진(좌) 동공(=조리개)이 열린 상태, 사진(우) 동공(=조리개)이 좁아진 상태\n\n![[notes/images/image (19).png]]\n\n","lastmodified":"2024-05-28T04:00:30.69253101Z","tags":[]},"/private/diary/20231017%ED%99%94":{"title":"20231017(화)","content":"성훈선생님은 당근마켓으로 이직했다고 한다. 나는 떨어졌는데.. 준비를 제대로 안 하기도 했지만 그래도 마음이 착잡하다. 내년 5월 이후에 제대로 이직 준비 해서 어딘가 좋은데 가야겠다. 다른 어떤 기회가 올까?\n\n일단 내 강점은 인프라부터 웹,앱까지 다 해봤다는 것, 그리고 팀장 역할도 해왔다는 것.\n\n이력서 정리 잘 하자. 물류팀에서 개발했던 정산시스템(오더 업로드, 세금계산서 매칭)과 세금계산서 발급, 국세청 전자세금계산서와 오더 자동매칭 기능 등등.. 면접에서 면접자가 질문할 만한 꼭지들을 의도하자.\n\n겸손하고 자신없는 태도보다는 약간은 당당하고 자신있게, 여기 말고도 갈 데 많다는 당당함이 필요하다. 시스템 인터뷰 준비도 하고 AWS랑 Kubernetes 자격증도 따고 코딩테스트나 Kata(로버트 마틴 함수형 책에 링크 있음)도 꾸준히 해보자\n\nmysql connector 글도 마저 쓰고. 스스로를 믿자, 열심히 준비해서 도전하면 다 된다. 차라리 영어공부 열심히 해서 AWS나 구글 같은 빅테크에 가든지.","lastmodified":"2024-05-28T04:00:30.708531121Z","tags":[]},"/private/diary/20231018%EC%88%98":{"title":"20231018(수)","content":"","lastmodified":"2024-05-28T04:00:30.708531121Z","tags":[]},"/private/diary/20231030%EC%9B%94":{"title":"20231030(월)","content":"달리기를 안 하니까 부정적인 생각이 또 올라온다.\n\n달리기는 매일 하자.\n\n요새 아침 6시 30분에 일어나서 회사에 7시 30분까지 출근하고 4시 30분에 퇴근하는데 좋다. 우울증약의 효과가 나타나는 것 같다. 눈앞의 일에 집중하고 미래를 대비하자, 걱정하는게 아니라.","lastmodified":"2024-05-28T04:00:30.708531121Z","tags":[]}}